name: Release
on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Type of version bump'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

jobs:
  bump-version:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.get_version.outputs.new_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump Version
        run: node scripts/bump-version.mjs --type=${{ github.event.inputs.bump_type }}

      - name: Update KeyAuth Version
        env:
          KEYAUTH_SELLER_KEY: ${{ secrets.KEYAUTH_SELLER_KEY }}
        run: node scripts/update-keyauth.mjs

      - name: Get New Version
        id: get_version
        run: |
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_tag=v.$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Commit and Push
        run: |
          git add package.json src-tauri/tauri.conf.json
          git commit -m "chore(release): $NEW_VERSION"
          git push origin main
          git tag v.$NEW_VERSION
          git push origin v.$NEW_VERSION

  release:
    needs: bump-version
    if: always() && (needs.bump-version.result == 'success' || needs.bump-version.result == 'skipped')
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            args: "--target universal-apple-darwin"
            rust_targets: "aarch64-apple-darwin,x86_64-apple-darwin"
          - platform: ubuntu-22.04
            args: ""
            rust_targets: ""
          - platform: windows-latest
            args: ""
            rust_targets: ""
            portable: true
          - platform: windows-latest
            args: "--target aarch64-pc-windows-msvc"
            rust_targets: "aarch64-pc-windows-msvc"

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.bump-version.outputs.new_tag || github.ref_name }}

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Sync Version from Tag
        shell: bash
        run: |
          TAG_NAME=${{ needs.bump-version.outputs.new_tag || github.ref_name }}
          if [[ "$TAG_NAME" == v* ]]; then
            VERSION=${TAG_NAME#v}
            # Remove leading dot if present (e.g. v.1.9.4 -> .1.9.4 -> 1.9.4)
            VERSION=${VERSION#.}
            echo "Syncing version to $VERSION from tag $TAG_NAME"
            echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              pkg.version = '$VERSION';
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
              
              const tauriConf = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
              tauriConf.version = '$VERSION';
              fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(tauriConf, null, 2));

              // Update public/version.json for runtime check
              const versionData = { version: '$VERSION' };
              fs.writeFileSync('public/version.json', JSON.stringify(versionData, null, 2));
            "
          else
            echo "Tag $TAG_NAME does not start with 'v', skipping version sync."
          fi

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_targets }}

      - name: Install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        run: npm install

      - name: Read Changelog
        id: read_changelog
        shell: bash
        run: |
          if [ -f CHANGELOG.md ]; then
            echo "Reading CHANGELOG.md..."
            body=$(cat CHANGELOG.md)
            EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
            echo "body<<$EOF" >> $GITHUB_OUTPUT
            echo "$body" >> $GITHUB_OUTPUT
            echo "$EOF" >> $GITHUB_OUTPUT
          else
            echo "CHANGELOG.md not found."
            echo "body=See the assets to download this version and install." >> $GITHUB_OUTPUT
          fi

      - name: Build the app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          VITE_KEYAUTH_NAME: Fiip
          VITE_KEYAUTH_OWNERID: wVgfmuIs9X
          VITE_KEYAUTH_SECRET: ${{ secrets.VITE_KEYAUTH_SECRET }}
          VITE_KEYAUTH_VERSION: ${{ env.APP_VERSION }}
          VITE_KEYAUTH_APIURL: https://keyauth.win/api/1.2/
        with:
          tagName: ${{ needs.bump-version.outputs.new_tag || github.ref_name }}
          releaseName: 'App v__VERSION__'
          releaseBody: ${{ steps.read_changelog.outputs.body }}
          releaseDraft: true
          prerelease: false
          args: ${{ matrix.args }}
          
      - name: Package Portable Version
        if: matrix.portable == true
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $TAG_NAME = "${{ needs.bump-version.outputs.new_tag || github.ref_name }}"
          $VERSION = $TAG_NAME -replace '^v', ''
          $ZIP_NAME = "Fiip-Portable-${VERSION}-Windows-x64.zip"
          
          echo "Packaging portable version: $ZIP_NAME"
          
          # Paths
          $EXE_PATH = "src-tauri/target/release/fiip.exe"
          if (-not (Test-Path $EXE_PATH)) {
            $EXE_PATH = "src-tauri/target/x86_64-pc-windows-msvc/release/fiip.exe"
          }

          $MARKER_PATH = "src-tauri/.portable"
          
          # Verify files exist
          if (-not (Test-Path $EXE_PATH)) {
            Write-Error "Executable not found at $EXE_PATH or src-tauri/target/release/fiip.exe"
            # List contents of target release to debug if needed
            if (Test-Path "src-tauri/target/release") {
                Get-ChildItem "src-tauri/target/release"
            }
            exit 1
          }
          if (-not (Test-Path $MARKER_PATH)) {
            New-Item -Path $MARKER_PATH -ItemType File -Force | Out-Null
          }
          
          # create a temporary directory for zipping
          if (Test-Path "temp_portable") { Remove-Item "temp_portable" -Recurse -Force }
          New-Item -ItemType Directory -Force -Path "temp_portable" | Out-Null
          
          # Rename executable to include Portable
          Copy-Item $EXE_PATH -Destination "temp_portable/Fiip-Portable.exe"
          Copy-Item $MARKER_PATH -Destination "temp_portable/.portable"
          
          # Zip it
          Compress-Archive -Path "temp_portable/*" -DestinationPath $ZIP_NAME -Force
          
          # Upload
          gh release upload $TAG_NAME $ZIP_NAME


  generate-updater-json:
    needs: [release, bump-version]
    if: always() && (needs.release.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          
      - name: Install dependencies
        run: npm install

      - name: Generate latest.json
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ needs.bump-version.outputs.new_tag || github.ref_name }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const tagName = process.env.TAG_NAME;
            const { owner, repo } = context.repo;

            // Clean version string (remove 'v' prefix and potential leading dot)
            const version = tagName.replace(/^v/, '').replace(/^\./, '');
            console.log(`TagName: ${tagName} -> Cleaned Version: ${version}`);
            
            // Validate SemVer
            // Allow standard X.Y.Z and pre-release tags like X.Y.Z-beta.1
            if (!/^\d+\.\d+\.\d+(-[a-zA-Z0-9.]+)?$/.test(version)) {
                core.setFailed(`Version ${version} is not valid SemVer (X.Y.Z or X.Y.Z-tag)`);
                return;
            }

            console.log(`Fetching release for tag ${tagName} (Version: ${version})...`);
            
            try {
                const release = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
                const assets = release.data.assets;
                
                console.log('ðŸ“¦ Assets found:', assets.map(a => a.name).join(', '));
                
                const platforms = {};
                let signatureCount = 0;
                
                async function getSignature(assetName, assetUrl) {
                  const sigName = assetName + '.sig';
                  const sigAsset = assets.find(a => a.name === sigName);
                  
                  if (sigAsset) {
                    console.log(`âœ… Found existing signature for ${assetName}`);
                    try {
                        const download = await github.rest.repos.getReleaseAsset({
                          owner,
                          repo,
                          asset_id: sigAsset.id,
                          headers: { accept: 'application/octet-stream' }
                        });
                        return new TextDecoder().decode(download.data);
                    } catch (e) {
                        console.error(`Failed to download signature for ${assetName}:`, e);
                        return null;
                    }
                  }
                  
                  console.log(`âš ï¸ Signature file not found for ${assetName}. Attempting to generate it...`);
                  
                  if (!process.env.TAURI_SIGNING_PRIVATE_KEY) {
                      console.warn("âŒ No private key available to sign.");
                      return null;
                  }

                  try {
                      // Download the asset
                      console.log(`Downloading ${assetName}...`);
                      const download = await github.rest.repos.getReleaseAsset({
                          owner,
                          repo,
                          asset_id: assets.find(a => a.name === assetName).id,
                          headers: { accept: 'application/octet-stream' }
                      });
                      fs.writeFileSync(assetName, Buffer.from(download.data));
                      
                      // Sign it
                      console.log(`Signing ${assetName}...`);
                      // We use npx tauri signer sign
                      // Pass keys via env vars
                      const env = {
                          ...process.env,
                          TAURI_PRIVATE_KEY: process.env.TAURI_SIGNING_PRIVATE_KEY,
                          TAURI_PRIVATE_KEY_PASSWORD: process.env.TAURI_SIGNING_PRIVATE_KEY_PASSWORD
                      };
                      
                      await exec.exec('npx', ['tauri', 'signer', 'sign', assetName], { env });
                      
                      if (fs.existsSync(sigName)) {
                          const sigContent = fs.readFileSync(sigName, 'utf-8');
                          
                          // Upload the new signature
                          console.log(`Uploading ${sigName}...`);
                          await github.rest.repos.uploadReleaseAsset({
                              owner,
                              repo,
                              release_id: release.data.id,
                              name: sigName,
                              data: fs.readFileSync(sigName)
                          });
                          
                          return sigContent;
                      } else {
                          console.error("Signer command finished but .sig file is missing.");
                          return null;
                      }
                  } catch (e) {
                      console.error(`Failed to generate signature for ${assetName}:`, e);
                      return null;
                  }
                }

                for (const asset of assets) {
                  if (asset.name.endsWith('.sig') || asset.name === 'latest.json') continue;
                  
                  let platformKey = null;
                  // Windows
                  if (asset.name.endsWith('.exe') || asset.name.endsWith('.msi')) {
                    if (asset.name.includes('aarch64')) platformKey = 'windows-aarch64';
                    else platformKey = 'windows-x86_64';
                  } 
                  // Linux
                  else if (asset.name.endsWith('.AppImage') || asset.name.endsWith('.deb')) {
                    platformKey = 'linux-x86_64';
                  } 
                  // macOS
                  else if (asset.name.endsWith('.app.tar.gz')) {
                     if (asset.name.includes('aarch64')) platformKey = 'darwin-aarch64';
                     else if (asset.name.includes('x64')) platformKey = 'darwin-x86_64';
                     else if (asset.name.includes('universal')) platformKey = 'darwin-universal'; 
                  }
                  
                  if (platformKey) {
                     console.log(`Processing asset ${asset.name} for platform ${platformKey}...`);
                     const signature = await getSignature(asset.name, asset.browser_download_url);
                     
                     if (signature) {
                        const entry = {
                           signature: signature.trim(),
                           url: asset.browser_download_url
                        };
                        
                        if (platformKey === 'darwin-universal') {
                            platforms['darwin-aarch64'] = entry;
                            platforms['darwin-x86_64'] = entry;
                        } else {
                            platforms[platformKey] = entry;
                        }
                        signatureCount++;
                     } else {
                        console.warn(`âŒ Skipping ${platformKey} because signature is missing.`);
                     }
                  }
                }
                
                if (signatureCount === 0) {
                    console.warn("âš ï¸ No signatures found for any platform. The updater will not work.");
                }

                const latestJson = {
                  version: version,
                  notes: release.data.body || `Update to version ${version}`,
                  pub_date: release.data.published_at,
                  platforms
                };
                
                console.log('Generated latest.json content:', JSON.stringify(latestJson, null, 2));
                fs.writeFileSync('latest.json', JSON.stringify(latestJson, null, 2));
                
                // Delete existing latest.json if it exists (to allow re-runs)
                const existingLatest = assets.find(a => a.name === 'latest.json');
                if (existingLatest) {
                   console.log('Deleting existing latest.json...');
                   await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: existingLatest.id });
                }
                
                console.log('Uploading new latest.json...');
                await github.rest.repos.uploadReleaseAsset({
                  owner,
                  repo,
                  release_id: release.data.id,
                  name: 'latest.json',
                  data: fs.readFileSync('latest.json')
                });
                console.log('âœ… latest.json successfully uploaded!');

            } catch (error) {
                core.setFailed(`Action failed with error: ${error.message}`);
            }
